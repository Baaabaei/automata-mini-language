# -*- coding: utf-8 -*-
"""Untitled17.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tIuQjhz1ohemzST0EvaSG_wOI7L2u8Cx
"""

from collections import defaultdict

# Defining the grammar
TOKENS = ['a', 'b', 'c']
WHITESPACE = ' \t\n'

# tokenizing
def tokenize(code):
    tokens = []
    i = 0
    while i < len(code):
        if code[i] in WHITESPACE:
            i += 1
            continue
        for token in TOKENS:
            if code[i:].startswith(token):
                tokens.append(token)
                i += len(token)
                break
    return tokens

# Creating automata for each token
def create_automaton(token):
    automaton = defaultdict(dict)
    start_state = 0
    for i, char in enumerate(token):
        automaton[i][char] = i + 1
    automaton[len(token)] = {}  # Final state is an empty dictionary
    return automaton, start_state

# Combining automatas using the union operation (OR)
def combine_automata(automata):
    combined_automaton = defaultdict(dict)
    start_states = []
    final_states = []

    for automaton, start_state in automata:
        start_states.append(start_state)
        for state, transitions in automaton.items():
            if not transitions:  # Final state
                final_states.append(state)
            for char, next_state in transitions.items():
                combined_automaton[(state, char)] = next_state

    # Creating new start state and transitions to initial states
    new_start_state = len(combined_automaton)
    for start_state in start_states:
        combined_automaton[(new_start_state, '')] = start_state

    # Creating new final state and transitions from final states
    new_final_state = len(combined_automaton) + 1
    for final_state in final_states:
        combined_automaton[(final_state, '')] = new_final_state

    return combined_automaton, new_start_state, new_final_state

# Converting NFA to DFA
def nfa_to_dfa(nfa, start_state, final_state):
    dfa = defaultdict(dict)
    start_state = (start_state,)
    queue = [start_state]
    while queue:
        state = queue.pop(0)
        for char in TOKENS + ['']:
            next_states = set()
            for s in state:
                next_state = nfa.get((s, char), None)
                if next_state is not None:
                    next_states.add(next_state)
            next_state = tuple(sorted(next_states))
            if next_state not in dfa:
                queue.append(next_state)
            dfa[state][char] = next_state

    # Mark final states in the DFA
    final_states = [state for state in dfa if final_state in state]
    for state in final_states:
        dfa[state][''] = 'final'

    return dfa, start_state



